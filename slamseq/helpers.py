#!/usr/bin/env python3

import pyranges as pr
import pandas as pd
import numpy as np
from typing import Literal

def get_terminal_regions(gr: pr.PyRanges,
                         feature_col = "Feature",
                         feature_key = "exon",
                         id_col = "transcript_id",
                         region_number_col = "exon_number",
                         number_type: Literal["stranded", "unstranded"] = "stranded",
                         which_region: str = "last",
                         filter_single = False,
                         ):
    '''Return the first/last interval in group of intervals

    Requires a column that provides a 1..n numbering of intervals within each group (can be generated by add_region_number). Extraction will always be with respect to strand (can handle strand-aware/non-strand aware ranking in region_number_col) 

    Parameters
    ----------
    gr : pr.PyRanges
        _description_
    feature_col : str, optional
        _description_, by default "Feature"
    feature_key : str, optional
        _description_, by default "exon"
    id_col : str, optional
        _description_, by default "transcript_id"
    region_number_col : str, optional
        _description_, by default "exon_number"
    number_type : str, optional
        _description_, by default ["stranded", "unstranded"]
    which_region : str, optional
        _description_, by default "last"
    filter_single : bool, optional
        _description_, by default False

    Returns
    -------
    _type_
        _description_
    '''


    assert number_type in ["stranded", "unstranded"]
    assert which_region in ["first", "last"]
    assert region_number_col in gr.columns.tolist()
    assert feature_col in gr.columns.tolist()
    assert id_col in gr.columns.tolist()

    # Make sure only 'exon' features are in the gr
    assert gr.as_df()[feature_col].drop_duplicates().tolist() == [feature_key], "only {} entries should be present in gr".format(feature_key)

    # Make sure region_number_col is int
    # assert gr.as_df()[region_number_col].dtype

    # Make sure gr is sorted by transcript_id & 'region number' (ascending order so 1..n)
    gr = gr.apply(lambda df: df.sort_values(by=[id_col, region_number_col], ascending=True))


    # Filter out single-exon transcripts
    if filter_single:
        print("Filtering for multi-exon transcripts...")
        print("Before: {}".format(len(set(gr.as_df()[id_col].tolist()))))

        # Setting to 'False' marks all duplicates as True (so keep these)
        gr = gr.subset(lambda df: df.duplicated(subset=[id_col], keep=False), nb_cpu=1)

        print("After: {}".format(len(set(gr.as_df()[id_col].tolist()))))


    if number_type == "stranded":
        # source = None means that 1 = first region of group regardless of strand
        # Pick last region entry by max region number for each transcript (id_col)
        # Pick first region entry by min region number for each transcript (id_col)

        # keep="last" sets last in ID to 'False' and all others true (negate to keep last only)
        # keep="first" sets first in ID to 'False'

        out_gr = gr.subset(lambda df: ~(df.duplicated(subset=[id_col], keep=which_region)),
                               nb_cpu=1
                              )


    else:
        # Numbering doesn't respect strand
        # Need to flip selecting first/last in group depending on strand
        # minus strand - pick min if Minus strand, max if plus strand

        if which_region == "first":
            # + strand - pick first in group, - strand - pick last in group

            out_gr = (gr.subset(lambda df:
                                    #1. plus strand & first in group/ID
                                    (df["Strand"] == "+") & ~(df.duplicated(subset=[id_col],
                                                                            keep="first")) |
                                    #2. minus strand & last in group/ID
                                    (df["Strand"] == "-") & ~(df.duplicated(subset=[id_col],
                                                                            keep="last")),
                                    nb_cpu=1)
                     )

        elif which_region == "last":
            # + strand - pick last in group/ID
            # - strand - pick first in group/ID
            out_gr = (gr.subset(lambda df:
                                    #1. plus strand & last in group/ID
                                    (df["Strand"] == "+") & ~(df.duplicated(subset=[id_col],
                                                                            keep="last")) |
                                    #2. minus strand & first in group/ID
                                    (df["Strand"] == "-") & ~(df.duplicated(subset=[id_col],
                                                                            keep="first")),
                                    nb_cpu=1)
                     )


    return out_gr


def _df_swap_coord(df: pd.DataFrame,
                   change: Literal['Start', 'End'],
                   replace_col: str
                   ):
    '''Swap one end of a coordinate range (i.e. either start or end) with a joined value

    Note: intended to be applied to internal df of pyranges 0.x/1.x dataframe i.e. all strand values are the same

    Adapted from pr.methods.new_position._new_position (to only swap a single coordinate)

    Parameters
    ----------
    df : pd.DataFrame
        _description_
    change : Literal[&#39;Start&#39;, &#39;End&#39;]
        _description_
    replace_col : str
        _description_
    old_out_suffix : str
        _description_

    Returns
    -------
    _type_
        _description_
    '''    ''''''
    
    # '''
    # Swap values in Start/End coordinates with a provided column
    # Adapted from pr.methods.new_position._new_position (to only swap a single coordinate)
    # '''
    assert isinstance(df, pd.DataFrame)
    assert change in ["Start", "End"]
    assert replace_col in df.columns

    # copy of original    
    to_change = df[change].copy()
    
    df.loc[:, change] = df[replace_col]
    df.loc[:, replace_col] = to_change

    return df


def _df_update_3p(df: pd.DataFrame, replace_suffix: str = "_b"):
    '''Update the 3' (strand-aware) coordinate of a joined internal PyRanges dataframe

    e.g. gr.apply(lambda df: _df_update_3p(df))

    Parameters
    ----------
    df : pd.DataFrame
        _description_
    '''

    assert "Strand" in df.columns
    assert (df["Strand"] == "+").all() or (df["Strand"] == "-").all()

    if (df["Strand"] == "+").all():
        # Update End col to update 3'end of interval
        out_col = "End" + replace_suffix
        assert out_col in df.columns
        out = _df_swap_coord(df, "End", out_col)
        

    else:
        # Update Start col to update 3'end of interval
        out_col = "Start" + replace_suffix
        assert out_col in df.columns
        out = _df_swap_coord(df, "Start", out_col)
    
    out_msk = out["End"] - out["Start"] <= 0
    print(f"Number of negative or zero-length updated intervals to be dropped - {sum(out_msk)}")
    out = out[~out_msk]

    return out


def _df_update_5p(df: pd.DataFrame, replace_suffix: str = "_b"):
    '''Update the 5' (strand-aware) coordinate of a joined internal PyRanges dataframe

    e.g. gr.apply(lambda df: _df_update_5p(df))

    Parameters
    ----------
    df : pd.DataFrame
        _description_
    '''

    assert "Strand" in df.columns
    assert (df["Strand"] == "+").all() or (df["Strand"] == "-").all()

    if (df["Strand"] == "+").all():
        # Update Start col to update 5'end of interval
        out_col = "Start" + replace_suffix
        assert out_col in df.columns
        out = _df_swap_coord(df, "Start", out_col)
        
    else:
        # Update End col to update 5'end of interval
        out_col = "End" + replace_suffix
        assert out_col in df.columns
        out = _df_swap_coord(df, "End", out_col)
    
    out_msk = (out["End"] - out["Start"]) <= 0
    print(f"Number of negative or zero-length updated intervals to be dropped - {sum(out_msk)}")
    out = out[~out_msk]

    return out