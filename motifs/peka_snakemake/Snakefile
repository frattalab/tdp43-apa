import pandas as pd
import os

# Extract values from sample table based on the wildcard
def get_param(wildcards, param_name):
    sample = wildcards.sample
    if sample in sample_table['comparison_name'].values:
        index = sample_table[sample_table['comparison_name'] == sample].index[0]
        return sample_table.at[index, param_name]
    else:
        raise ValueError(f"Sample {sample} not found in sample_table")


# Read the sample table using pandas
sample_table = pd.read_csv(config["sample_table"])

# Define the list of sample names based on the 'comparison_name' column
sample_names = sample_table['comparison_name'].tolist()

# base output directory
base_outdir = config["base_output_dir"]


# Define a rule to generate the target files using the 'sample' wildcard
rule all:
    input:
        expand(os.path.join(base_outdir, "{sample}", "peka.done"), sample=sample_names)


rule pas_to_peka_beds:
    input:
        pas=lambda wildcards: get_param(wildcards, 'regions_bed')
    output:
        comb_bed=os.path.join(base_outdir, "peka_beds", "{sample}.all.bed"),
        reg_bed=os.path.join(base_outdir, "peka_beds", "{sample}.foreground.bed")
    params:
        script="scripts/pas_to_peka_beds.py",
        foreground_key=lambda wildcards: get_param(wildcards, 'foreground_key'),
        group1_key=lambda wildcards: get_param(wildcards, 'group1_key'),
        group2_key=lambda wildcards: get_param(wildcards, 'group2_key'),
        output_prefix = os.path.join(base_outdir, "peka_beds", "{sample}")

    log:
        stdout=os.path.join(base_outdir, "logs", "pas_to_peka_beds.{sample}.stdout.txt"),
        stderr=os.path.join(base_outdir, "logs", "pas_to_peka_beds.{sample}.stderr.txt")

    shell:
       """python {params.script} \
       -f {params.foreground_key} \
       -g1 {params.group1_key} \
       -g2 {params.group2_key} \
       {input.pas} \
       {params.output_prefix} \
       1> {log.stdout} \
       2> {log.stderr}
       """




#Note: PEKA's final output file is quite complicated to track with Snakemake
# f"{sample_name}_{kmer_length}mer_cluster_distribution_{region}.tsv"
# where sample_name is the input comb_bed file with .bed suffix removed
# I'm too lazy to code it out, so instead use an && so that empty file is created only when peka command finishes successfully
rule peka:
    input:
        comb_bed=rules.pas_to_peka_beds.output.comb_bed,
        reg_bed=rules.pas_to_peka_beds.output.reg_bed,
        genome=config["genome"],
        genome_idx=config["genome_idx"]
            
    output:
        os.path.join(base_outdir, "{sample}", "peka.done") 

    params:
        kmer=config["kmer"],
        window=config["window"],
        distal_window=config["distal_window"],
        specific_region=config["specific_region"],
        alloutputs=config["alloutputs"],
        pos=config["pos"],
        regions=config["regions_gtf"],
        outdir = os.path.join(base_outdir, "{sample}", ""),
        tmpdir = os.path.join(base_outdir, "{sample}", "tmp")

    log:
        stdout=os.path.join(base_outdir, "logs", "peka.{sample}.stdout.txt"),
        stderr=os.path.join(base_outdir, "logs", "peka.{sample}.stderr.txt")

    shell:
        """
        mkdir -p {params.tmpdir} && export TMPDIR={params.tmpdir}
        peka -x {input.comb_bed} \
        -i {input.reg_bed} \
        -g {params.genome} \
        -gi {params.genome_idx} \
        -r {params.regions} \
        -k {params.kmer} \
        -p {params.pos} \
        -w {params.window} \
        -dw {params.distal_window} \
        --specificregion {params.specific_region} \
        --alloutputs {params.alloutputs} \
        -o {params.outdir} \
        1> {log.stdout} \
        2> {log.stderr} && \
        touch {output}

        """
